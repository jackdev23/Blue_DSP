/*******************************************************************************
Copyright 2018 Luca Facchinetti, IW2NDH
 All trademarks referred to in source code and documentation 
 are copyright their respective owners.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed WITHOUT ANY WARRANTY.
    If you offer a hardware kit using this software, 
    show your appreciation by sending the author
    a complimentary kit or a donation to a cats refuge ;-)
 *****************************************************************************/
#include "xc.h"
#include "dsp.h"
#include "../h/adcdacDrv.h"
#include "../h/timers.h"
//#include "../h/DEE Emulation 16-bit.h"
#include "../h/OneButton.h"
//#include "../h/pitch.h"
#include "../h/oled.h"
#include "../h/fft.h"
#include <libpic30.h>
#include <stdio.h>
//#include "../h/funcSelector.h"

#define GREEN_LED       _LATC7  //PIN 3
#define YELLOW_LED		_LATC6  //PIN 2
#define RED_LED         _LATB2  //PIN 23


#define GREEN_LED_TRIS  TRISCbits.TRISC7
#define YELLOW_LED_TRIS  TRISCbits.TRISC6
#define RED_LED_TRIS  TRISBbits.TRISB2

unsigned int DEEaddr1 = 4, DEEaddr2 = 261, DEEaddr3 = 302;
int invalid_flag;

unsigned char applyNS; /* Indicates if NS should be ON or OFF		*/
int applyFilter;
unsigned char squelch; //DEEaddr3
unsigned char filterIdx; //DEEaddr1

extern int overloadInput;
extern int overloadOutput;
//#define noiseLevels 9
//const int level[noiseLevels] = {0, 9, 11, 13, 15, 17, 20, 24, 35};
extern unsigned char nsLevelIdx; /* Selected NS Level			DEEaddr2			*/

extern fractional signalDENOISE[NUMSAMP];
extern int volatile flag;

char buffer [5];
unsigned char drwFFTbuffer[FFT_BLOCK_LENGTH];

//// VU meter background mask image:
//static const unsigned char VUMeter[] = {
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x1D, 0xC0, 0x00, 0x2E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0xE0, 0x40, 0x1C, 0x00, 0x1C, 0x10,
//  0x00, 0x05, 0x40, 0x00, 0x2A, 0x00, 0x00, 0x02, 0x00, 0x00, 0xA0, 0x40, 0x04, 0x00, 0x04, 0x10,
//  0x1F, 0x1D, 0x40, 0x00, 0x2A, 0x00, 0x00, 0x0E, 0x00, 0x00, 0xA0, 0x40, 0x1C, 0x00, 0x1C, 0x7C,
//  0x00, 0x11, 0x40, 0x00, 0x2A, 0x00, 0x00, 0x02, 0x00, 0x00, 0xA0, 0x40, 0x10, 0x00, 0x04, 0x10,
//  0x00, 0x1D, 0xC0, 0x00, 0x2E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0xE0, 0x40, 0x1C, 0x00, 0x1C, 0x10,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 0x40, 0x08, 0x00, 0x08, 0x00,
//
//  0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x40, 0x40, 0x08, 0x00, 0x08, 0x00,
//  0x00, 0x02, 0x00, 0x00, 0x08, 0x08, 0x08, 0x04, 0x10, 0x40, 0x5F, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
//  0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x01, 0x00, 0x00, 0x20, 0x00, 0x40, 0x01, 0x00, 0x10, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x03, 0x80, 0x01, 0xDC, 0x02, 0x38, 0x0E, 0xE0, 0xEE, 0x05, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x02, 0x80, 0x00, 0x54, 0x02, 0xA8, 0x08, 0xA0, 0xAA, 0x05, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x02, 0x80, 0x01, 0xD4, 0x02, 0xA8, 0x0E, 0xA0, 0xEA, 0x05, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x02, 0x80, 0x01, 0x14, 0x03, 0xA8, 0x0A, 0xA0, 0xAA, 0x05, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x03, 0x80, 0x01, 0xDC, 0x00, 0xB8, 0x0E, 0xE0, 0xEE, 0x05, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0x94, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x14, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x17, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
//};
//void writePixel(int16_t x, int16_t y, uint16_t color) {
//  SSD1306_DrawPixel(x, y, color);
//}
//void drawBitmap(int16_t x, int16_t y, const uint8_t bitmap[],
//                              int16_t w, int16_t h, uint16_t color) {
//
//  int16_t byteWidth = (w + 7) / 8; // Bitmap scanline pad = whole byte
//  uint8_t byte = 0;
//int16_t j;
//int16_t i;
//  //startWrite();
//  for ( j = 0; j < h; j++, y++) {
//    for ( i = 0; i < w; i++) {
//      if (i & 7)
//        byte <<= 1;
//      else
//        byte = bitmap[j * byteWidth + i / 8];
//      if (byte & 0x80)
//        writePixel(x + i, y, color);
//    }
//  }
//  //endWrite();
//}
//
//int val;
//int pos;
//int err;
//double err_accum;
//int peakValue;
//
//void test() {
//  //these gains affect rise/fall time, overshoot, oscillations
//  double p_gain = 0.1; //proportional gain
//  double i_gain = 0.8; //integral gain
//
//  val = (int)(peakValue/320); //val is the measured setpoint/reference, divided by 8 because the adc is 10 bits but the meter range I've chosen is only 7 bits
// 
//  if (val > 127) val = 0; 
//  err = val - pos; //the error is how far off we are from the setpoint, pos is the current needle position
//
//  err_accum += i_gain * err; //here we calculate the scaled factor of how long there's been an error
//
//  pos += (int) (p_gain * err + err_accum); //we add the accumulated error with the current error scaled by the proportional gain to calculate what the next position should be
//  // The position must be an integer from 0-127 so we cast the calculated value from double to int
//
//  if (pos > 127) pos = 127; //these are limiters to make sure the output never exceeds the max or min deflection of the needle
//  if (pos < 0) pos = 0;
//}
//int hMeter = 65;                      // horizontal center for needle animation
//int vMeter = 85;                      // vertical center for needle animation (outside of dislay limits)
//int rMeter = 80;                      // length of needle animation or arch of needle travel
//float MeterValueLeft;
//const int sampleWindow = 5;          // sample window width in mS (50 mS = 20Hz)
//unsigned int sampleLeft;
//unsigned int PeakLeft = 400;                             // start needle fall max to min on start
//unsigned int fallTimeLeft;          // needle fallspeed
//
//void drawleft() {
//
//  MeterValueLeft = MeterValueLeft - 43;                            // shifts needle to zero position
//  SSD1306_ClearDisplay();                                  // refresh display for next step
//  drawBitmap(0, 0, VUMeter, 128, 64, 1);       // draws background white
//  int a1 = (hMeter + (sin(MeterValueLeft / 57.296) * rMeter)); // meter needle horizontal coordinate
//  int a2 = (vMeter - (cos(MeterValueLeft / 57.296) * rMeter)); // meter needle vertical coordinate
//
//  SSD1306_DrawLine(a1 - 2, a2, hMeter - 1, vMeter, 0);     // draws needle
//  SSD1306_DrawLine(a1 - 1, a2, hMeter - 1, vMeter, 1);     // draws needle
//  SSD1306_DrawLine(a1, a2, hMeter, vMeter, 1);         // draws needle
//  SSD1306_DrawLine(a1 + 1, a2, hMeter + 1, vMeter, 1);     // draws needle
//  SSD1306_DrawLine(a1 + 2, a2, hMeter + 1, vMeter, 0);     // draws needle
//  SSD1306_DisplaySH1106();
//}

void checkLedStatus(void) {
    GREEN_LED = applyNS;
    YELLOW_LED = applyFilter;
}

void initFromFlash(void) {

    filterIdx = 0;
    nsLevelIdx = 0;
    squelch = 0;
    //    /////FLASH READ
    //    DataEEInit();
    //    dataEEFlags.val = 0;
    //    filterIdx = DataEERead(DEEaddr1);
    //    nsLevelIdx = DataEERead(DEEaddr2);
    //    squelch = DataEERead(DEEaddr3);
    //
    //    ///////////////////
    //    if ((filterIdx < 0) | (filterIdx > 3))filterIdx = 0; //highpass
    //    if ((nsLevelIdx < 0) | (nsLevelIdx > noiseLevels - 1))nsLevelIdx = 0; // 0dB NS = OFF
    //    if ((squelch < 0) | (squelch > 1))squelch = 0; //squelch ON/OFF

    if (nsLevelIdx == 0)applyNS = 0;
    else applyNS = 1;
    if (filterIdx == 0) applyFilter = 0;
    else applyFilter = 1;
}
////TEST FREQ
//#define RED_LED         _LATC7  //PIN 4
//#define RED_LED_TRIS  TRISCbits.TRISC7
//RED_LED ^=1;  //toggle TEST FREQ

void click() {
    filterIdx++;
    if (filterIdx > 4) {
        filterIdx = 0;
        applyFilter = 0;
    } else {
        applyFilter = 1;
    }
    selectFilter(filterIdx);
    checkLedStatus();
}

void doubleclick() {
}

void press() {
    //    RCONbits.SWDTEN = 0; // Disable Watch Dog Timer 0.1 sec
    //    DataEEWrite(filterIdx, DEEaddr1);
    //    DataEEWrite(nsLevelIdx, DEEaddr2);
    //    DataEEWrite(squelch, DEEaddr3);
    //    RED_LED = 1;
    //    __delay_ms(200);
    //    RCONbits.SWDTEN = 1; // Enable Watch Dog Timer 0.1 sec
}

void clickS2() {
    nsLevelIdx++;
    if (nsLevelIdx > noiseLevels) {
        nsLevelIdx = 0;
        applyNS = 0;
    } else {
        applyNS = 1;
    }
    changeNoiseLevel(nsLevelIdx - 1);
    checkLedStatus();
}

void doubleclickS2() {
}

void pressS2() {
    RCONbits.SWDTEN = 0; // DIsable Watch Dog Timer 0.1 sec
    if (squelch == 0) squelch = 1;
    else squelch = 0;
    RED_LED = 1;
    __delay_ms(200);
    RCONbits.SWDTEN = 1; // Enable Watch Dog Timer 0.1 sec
}

void displayFFT() {
    fftCompute(signalDENOISE, drwFFTbuffer);
    SSD1306_DrawFastHLine(0, 26, 126, 1); //8 px = 6 dB
    SSD1306_DrawFastHLine(0, 34, 126, 1);
    SSD1306_DrawFastHLine(0, 42, 126, 1);
    SSD1306_DrawFastHLine(0, 50, 126, 1);
    SSD1306_DrawFastHLine(0, 63, 126, 1);
    SSD1306_DrawFastVLine(0, 26, 37, 1);
    SSD1306_DrawFastVLine(24, 26, 37, 1);
    SSD1306_DrawFastVLine(50, 26, 37, 1);
    SSD1306_DrawFastVLine(76, 26, 37, 1);
    SSD1306_DrawFastVLine(101, 26, 37, 1);
    SSD1306_DrawFastVLine(126, 26, 37, 1);
    int i;
    for (i = 1; i < FFT_BLOCK_LENGTH_HALF ; i++) {

        SSD1306_FillRect(126 - 2 * i, 63 - drwFFTbuffer[i], 1, 63, 1);
    }
}

void displayMenuTop() {
    if (applyFilter) {
        sprintf(buffer, "%d", filterIdx);
        SSD1306_DrawText(10, 0, buffer, 2);
    } else SSD1306_DrawText(5, 4, "off", 1);
    if (applyNS) {
        sprintf(buffer, "%d", nsLevelIdx);
        SSD1306_DrawText(43, 0, buffer, 2);
    } else SSD1306_DrawText(43, 4, "off", 1);
    if (squelch) {
        SSD1306_DrawText(80, 4, "On", 1);
    } else SSD1306_DrawText(80, 4, "off", 1);
    //    if (AutoNotch) {
    //        SSD1306_DrawText(95, 4, "On", 1);
    //    } else SSD1306_DrawText(95, 4, "off", 1);

    SSD1306_DrawText(5, 16, "FIL", 1);
    SSD1306_DrawText(43, 16, "NR", 1);
    SSD1306_DrawText(80, 16, "SQ", 1);
    //    SSD1306_DrawText(95, 16, "AN", 1);
}
unsigned char Button_Filter_OFF_HOLD; //COMMUTATION NARR_WIDE

int main(void) {
    //test BRANCH 2 in master
    INTCON2bits.ALTIVT = 0;
    // Configure Oscillator to operate the device at 40MIPS
    // Fosc= Fin*M/(N1*N2), Fcy=Fosc/2
    // Fosc= 7.37M*43/(2*2)=79.22Mhz for ~40MIPS input clock
    PLLFBD = 38; //M = 40 //41  M=43  
    CLKDIVbits.PLLPOST = 0; // N1=2
    CLKDIVbits.PLLPRE = 0; // N2=2
    OSCTUN = 0; // Tune FRC oscillator, if FRC is used

    // Disable Watch Dog Timer
    RCONbits.SWDTEN = 0;

    // Clock switch to incorporate PLL
    __builtin_write_OSCCONH(0x01); // Initiate Clock Switch to
    // FRC with PLL (NOSC=0b001)
    __builtin_write_OSCCONL(0x01); // Start clock switching
    while (OSCCONbits.COSC != 0b001); // Wait for Clock switch to occur

    // Wait for PLL to lock
    while (OSCCONbits.LOCK != 1) {
    };

    GREEN_LED_TRIS = 0;
    YELLOW_LED_TRIS = 0;
    RED_LED_TRIS = 0;

    Init_Timer1();

    OneButtonSetUp();
    attachClick(click);
    //attachDoubleClick(doubleclick);
    attachPress(press);
    attachClickS2(clickS2);
    //attachDoubleClickS2(doubleclickS2);
    attachPressS2(pressS2);

    initFromFlash();

    checkLedStatus();
    selectFilter(filterIdx);

    initAdc(); // Initialize the A/D converter to convert Channel 4
    dacInit1();
    initDma0(); // Initialize the DMA controller to buffer ADC data in conversion order
    initTmr3(); // Initialize the Timer to generate sampling event for ADC

    i2c1Reset();
    i2c1Enable(kI2C_400KHZ);
    __delay_ms(200);

    oledInitSH1106();

    SSD1306_ClearDisplay();
    oledCommand(0xA6); // 0xA6
    oledCommand(0xAF); //--turn on oled panel

    SSD1306_ClearDisplay();
    SSD1306_Display();
    init_window_mult(1);

    //    	//SELECTION TO FUNCION
    //        functionPutString funcPutStr;
    //		functionGetString getStr;
    //
    //		if(1) // PA6 OPEN = USB ,GND = UART
    //		{
    //			funcPutStr = &USB_PutString;
    //			getStr = &USB_GetString;
    //		}else {
    //			funcPutStr = &AAUART_PutString;
    //			getStr = &AAUART_GetString;
    //		}
    //		while(1){
    //			PROTOCOL_Handler(getStr,funcPutStr);
    //		}

    //      unsigned int PeaktoPeakLeft = 0;                             // peak-to-peak level
    //  unsigned int SignalMaxLeft = 0;
    //  unsigned int SignalMinLeft = 1024;

    RCONbits.SWDTEN = 1; // Ensable Watch Dog Timer 0.1 sec
    while (1) {
        ClrWdt(); //Reset Watch Dog Timer
        tick();
        if (flag) {
            //VUMETER
            //                test();
            //    PeaktoPeakLeft = (int)(peakValue/820);// SignalMaxLeft - SignalMinLeft;                      // max - min = peak-peak amplitude
            //    if (PeaktoPeakLeft > PeakLeft) {
            //      PeakLeft = PeaktoPeakLeft;// saves just the min levels
            //    } else if (PeaktoPeakLeft < PeakLeft) {
            //      fallTimeLeft = ((PeakLeft - PeaktoPeakLeft) / 2);
            //      PeakLeft = PeakLeft - fallTimeLeft;
            //    }
            //    MeterValueLeft = pos ;              // convert volts to arrow information sensitivity
            //
            //    drawleft();

            SSD1306_ClearDisplay();
            if (overloadInput) {
                RED_LED = 1;
                SSD1306_FillRoundRect(110, 6, 10, 15, 1,1);
            } else {
                RED_LED = 0;
                SSD1306_DrawRoundRect(110, 6, 10, 15, 1);
            }
            displayMenuTop();
            displayFFT();
            SSD1306_DisplaySH1106();

            flag = 0;
        }
    }
    return 0;
}
